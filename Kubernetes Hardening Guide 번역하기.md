[ID: 28]
[Tags: SEC KUBERNETES]
[Title: Kubernetes Hardening Guide 번역하기]
[WriteTime: 2023/10/20]
[ImageNames: 6be7c6b6-0f80-4ec1-929e-5c3e370a0b5c.png]

## Contents

1. Preamble
2. 보안 위협의 종류
3. 보안 위협이 생길 수 있는 곳
4. Pod 보안
5. ServiceAccount & Token
6. Namespace 분리
7. NetworkPolicy
8. Control Plane
9. ETCD
10. Kubectl
11. Secret
12. Cloud Infrastructure
13. 인가 / 인증
14. Audit log
15. References

## 1. Preamble

쿠버네티스 클러스터에 보안에 대해 공부하고 있다. 클러스터 보안의 광범위함, 부족한 정보, Deprecated/Beta 버전의 기능들에 대해 큰 혼란을 겪고있었다. 그러다가 미국의 National Security Agency(NSA)와 Cybersecurity and Infrastructure Security Agency(CISA)에서 쿠버네티스를 사용하는 미국의 국가기관들을 위해 22년도 여름에 작성한 쿠버네티스 보안 강화 가이드라인을 찾게 되었다.

이 가이드라인대로 따라간다고 100% 완벽하게 쿠버네티스 보안을 지킬 수 있는 것은 아니겠지만, 가이드라인을 읽으면서 `실제 개발될 서비스에서 적어도 이 정도의 보안 수준은 필요하겠다` 라는 Insparation은 얻을 수 있었다.

## 2. 보안 위협의 종류

1. 컨테이너 레벨

어플리케이션을 쿠버네티스에 배포할 때 여러 서드파티 컨테이너들이 사용된다. MSA의 효과적인 통신을 위해 메시지 큐, 지속적 전달과 배포를 위해 ArgoCD 등의 CD 툴 뿐만 아니라 각 언어 별 이미지도 사용된다.

컨테이너 이미지가 악의적인 목적으로 악성 코드를 심어둔 이미지일 경우  보안적인 위협이 될 수 있다.


2. 컨테이너 런타임

컨테이너는 호스트와의 격리를 위해 컨테이너 런타임을 사용한다. 각 노드에는 이 컨테이너 런타임이 설치되어있고, 실행된다. 이 컨테이너 런타임이 불안정할 경우 노드에서의 호스트와의 격리가 정상적으로 이루어지지 않을 수 있고, 보안적인 위협이 될 수 있다.


3. 인프라 스트럭처

쿠버네티스는 온프레미스 또는 클라우드 환경에 설치된다. 쿠버네티스의 기반이 되는 인프라에 문제가 있다면 보안적인 위협이 될 수 있다.

## 3. 보안 위협이 생길 수 있는 곳

1. 컨트롤플레인

컨트롤 플레인은 쿠버네티스의 핵심이다. API서버는 수 많은 쿠버네티스의 컴포넌트들과 연결되어있고, 컨트롤 플레인이 공격당하면 전체 클러스터에 큰 위협이 된다. 때문에 컨트롤 플레인에 대한 확실한 보안을 구현해야한다.


2. 워커노드

워커노드에는 kube-proxy와 kubelet이라는 kube-system 네임스페이스의 컴포넌트들이 있다. 이 kube-proxy와 kubelet을 통해 노드가 외부로 노출되기 때문에, 이 경로로 공격당할 수 있다.


3. 컨테이너

컨테이너화 된 어플리케이션을 통해서도 공격당할 수 있다. 이 경우 Pod 간 접근 제어를 적절히 설정해주지 않으면 privileged escalation을 통해 Pod에서 클러스터 전체로의 공격이 가능해지게 된다.

## Internal Threat

1. 관리자

RBAC(역할 기반 접근 제어)를 잘 설정해두어서 접근제어를 어느정도 구성할 수는 있지만, 어쨌든 쿠버네티스 클러스터 전체에 접근할 수 있고, 클러스터 전체를 관리할 수 있는 내부 관리자가 한 사람은 존재할 수 밖에 없다. 이 관리자의 보안 소홀이나 악의적 목적으로 서비스가 공격당할 수 있다.


2. 사용자

사용자는 클러스터 관리자는 아니지만 RBAC으로 권한이 제한되어있는 다른 개발자들을 의미한다. 전체 권한은 아니더라도 자신에게 할당된 권한 내에서 충분히 위협이 될 수 있다.


3. 클라우드 공급자

많은 쿠버네티스 클러스터가 클라우드 서비스 위에 설치되어있고, 이 클라우드 공급자(provider)가 보안적 문제가 있다면, 각 노드를 통해 공격당할 수 있다.

## 4. Pod 보안

1. ### 컨테이너 실행 권한

쿠버네티스에서 파드는 가장 작은 배포 단위이다. 때문에 보안이 중요한데, 많은 컨테이너가 루트 권한이 필요하지도 않은데 SuperUser 권한으로 실행되는 경우가 꽤 많다.

이 권한을 쿠버네티스에서 네이티브로 제공하는 리소스인 SecurityContext로 제어할 수 있긴하지만, 도커파일로 이미지 빌드할 때부터 컨테이너를 NonRoot로 실행하길 권장한다.

이미지가 Root로 빌드됐어도 강제로 NonRoot로 보안 레이어를 한 겹 덮어씌워주는 기능을 가진 컨테이너 런타임도 있는데, 한 겹 덮어씌우는만큼 관리와 운영이 복잡해지고, 기능이 안정적이지 않은 경우가 많아서 운영환경에서 해당 컨테이너 런타임만으로 보안을 커버하기엔 적합하지 않다.

2. ### 컨테이너 내부 권한

이렇게 컨테이너가 실행될 때의 권한을 제어하더라도, 컨테이너 내부에서 실행되는 프로세스에 대해서는 권한 제어를 안하는 경우 역시 많다. 컨테이너가 공격당할 때, 외부 다른 Pod로는 escalation이 일어나지 않더라도 공격자가 해당 컨테이너 내부에서는 파일시스템을 충분히 조작할 수 있게 된다.

그래서 컨테이너에 파일시스템을 다 잠그고, write이 필요한 컨테이너는 따로 세컨더리 볼륨을 마운트해서 해당 볼륨에서만 write이 가능하도록 제어하는 방식을 사용할 수 있다.

### 안전한 컨테이너 이미지


안전한 컨테이너 이미지를 빌드하기 위해서는 기본적으로


1. 안전한 컨테이너 레지스트리에서 이미지를 설치해야하고, 
2. Certified된 안전한 Provider의 이미지를 설치해야한다.

출처를 알 수 없는 이미지와 레지스트리의 경우 이미지 안에 어떤 식으로 악성 코드를 심어두었을 지 알 수 없기 때문이다.

안전한 레지스트리와 Provider의 이미지를 사용한다고 해도,  쿠버네티스에서 네이티브로 제공하는 **Admission Controller**(이하 어드미션 컨트롤러)와 **외부 이미지 스캐닝 도구**(trivy 등)를 활용하는 것이 좋다.

어드미션 컨트롤러는 API서버로 오는 모든 요청들을 인터셉트해서 인증/인가 과정을 거치게 강제한다. 인증/인가가 나지 않은 이미지는 배포를 할 수 없게 된다.

## 5. ServiceAccount & Token


쿠버네티스는 기본적으로 Pod가 생성될 때 default **ServiceAccount**(이하 서비스 어카운트)와 **Token**을 생성한다.

컨테이너화 된 대부분의 어플리케이션들은 서비스 어카운트로써 API서버로의 직접적인 접근을 필요로 하지않는데, 이 토큰을 공격자에게 탈취당하면 괜히 API서버로의 접근 권한을 쥐어주게 되면서 클러스터 범위로 공격이 확장될 수 있다.

토큰은 매니페스트에서 별도 필드를 설정해서 생성하지 않을  수 있다.

만약 클라우드(AWS IAM 등) 외부 인증을 위해 토큰을 생성/사용해야만 한다면 RBAC을 잘 설정해서 서비스 어카운트/사용자의 권한을 꼭 제어해야한다.

또한 쿠버네티스 내부에서의 컴포넌트들간의 접근 분리는 이루어지지 않는게 기본값이라서, 여러 리소스들과 Credentials을 분리해서 privilege escalation이 일어나지 않도록 해야한다.

리소스 분리를 위해서는 네이티브 리소스인 NetworkPolicy, 추가적으로 방화벽 사용할 수 있고, REST 요청시 시크릿과 내용을 암호화할 수 있도록 내부적으로도 TLS 암호화를 사용하는 것이 좋다.

## 6. Namespace 분리


네임스페이스를 분리한다고 리소스들이 격리되는 건 아니다. 서로 다른 네임스페이스끼리도 같은 네트워크에 속해있기 때문에, ClusterIP나 서비스 디스커버리를 활용해 내부 컴포넌트들끼리 서로 접근할 수 있다. 다만 네임스페이스를 분리하면 분리된 네임스페이스들을 통해 RBAC이나 NetworkPolicy로 격리를 쉽게 구현할 수 있다.

ClusterIP는 Pod가 죽은 후 재생성되면 새롭게 할당되기 때문에,  ClusterIP를 Static IP라고 생각하고 보안 규칙을 설정하면 안된다.

그래서 클러스터 내부에서 Static IP를 제공하는 **서비스**라는 오브젝트가 있는거고,  서비스가 살아있는 동안은 서비스가 가리키는 Pod들에 접근하는 유니크한 IP는 변하지 않을것이다. 이 서비스를 통해 보안 규칙을 설정하면 된다.

보안을 위해 외부로 서비스를 노출할 때는 TLS 인증을 꼭 받아야한다.

## 7. NetworkPolicy


NetworkPolicy(이하 네트워크 정책)는 네임스페이스, Pod, External-IP 사이의 트래픽을 제어한다. 이 네트워크 정책은 네트워크 플러그인(CNI)이 지원을 해야한다. 

정책을 설정할 때는 우선 모든 권한을 다 DENY시키고, 필요한 권한만을 추가하는 방식으로 설정하는 것이 좋다.

LimitRange와 **ResourceQuota**, **ProcessID Limit**을 통해 노드, 네임스페이스, pod별 리소스 제한이 가능하다. 한정된 스토리지를 리소스끼리 적절히 나눠서 사용하기 위해서 이 세 설정들을 적절히 구성하는 게 중요하다.

LimitRange(이하 리미트 레인지)로 특정 네임스페이스에 대해 각 파드/컨테이너가 사용하는 리소스를 제한할 수 있다.

리미트레인지는 네임스페이스 당 하나만 설정 가능하고, ResourceQuota는 네임스페이스 별로 사용하는 리소스의 limit을 관리할 수 있다. 레벨이 나눠져 있는 것으로 볼 수 있다.

ProcessID는 노드에 설정하는 것이고, 노드에서 쿠버네티스 시스템 데몬을 사용하는 pid의 수를 제한하는 것이다.

## 8. Control Plane


컨트롤 플레인은 앞서 말했듯이 쿠버네티스의 코어이다. 컨트롤 플레인은 파드를 생성히고, 시크릿을 읽고, 컨테이너 상태를 확인하고, 클러스터 커맨드를 실행하는 많은 중요한 역할을 맡고있다. 그래서 아주 완벽히 보호되어야하고, RBAC, TLS 암호화, 인증/인가, 다른 Pod들과의 네트워크 분리 등을 통해 인가되지 않은 사용자가 컨트롤플레인에 접근하는 것을 제어해야한다.

컨트롤플레인이 이렇게 중요한 역할을 맡고있기 떄문에, RBAC이나 네트워크 정책 등으로 모든 네임스페이스에서의 액세스를 다 차단해도 kube-system에 대한 접근은 차단이 안된다.

그래서 컨트롤 플레인이 위치하는 kube-system 네임스페이스에도 따로 접근을 막는 설정을 해줘야한다.

## 9. ETCD


ETCD는 current, desired state와 시크릿 데이터를 포함한 여러 핵심 데이터들을 저장하고 있는 클러스터 백엔드 데이터베이스이다.

그리고 **ETCD에 대해 write 권한이 있으면 전체 클러스터에 대한 접근 권한을 얻을 수 있게된다.**

이렇게 보안적인 측면에서도, 서비스적 측면에서도 아주 중요한 역할을 맡고있기 때문에, 


1. 컨트롤플레인에서 분리해서
2. API서버만 접근할 수 있도록 방화벽과 RBAC을 설정

하는 것이 좋다. 마치 프록시처럼 API서버를 거쳐야만 ETCD와 통신할 수 있도록 분리함으로써, API서버가 안전한 한 ETCD도 안전해지는 시스템을 구축할 수 있다.

> 유일한 통신 채널인 ETCD와 API서버 간 통신 역시 꼭 TLS로 암호화해야한다.

## 10. Kubectl


kubectl은 쿠버네티스 클러스터를 관리할 수 있게해주는 CLI이다. 이 kubectl은 ./kube/config 파일에 저장되어있는 클러스터, 사용자, 네임스페이스, 인증 정책 정보를 활용한다. config 파일이 임의로 공격자에 의해 변경될 수 있기 때문에, 함부로 변경되지 않게 보호해야하고 권한이 없는 사용자가 접근하지 못하게 막아야한다.

## 11. Secret


secret(이하 시크릿)은 패스워드, SSH 키, OAuth 키 등, 여러 Credentials에 대한 데이터를 가지고 있기 때문에 잘 보호해야한다. 


1. 외부 key management service(KMS)를 통해 시크릿을 보호할 수 있고,
2. data-at-rest 암호화를 통해 보호할 수도 있다. 

data-at-rest는 전송중이지 않은(사용되지 않고 보관중인) 데이터를 의미한다. `kube-apiserver` config에 `--encryption-provider-config` 옵션을 설정해서 이 기능을 활성화할 수 있다. 이 기능을 활성화하면 사용중이지 않은 secret들이 암호화되어 보관되게 된다.

이걸 적용한 후에 

```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
 
커맨드를 입력해야 기존에 있던 data-at-rest들도 암호화가 적용된다.

## 12. Cloud Infrastructure


클라우드 인프라를 사용한다면 해당 벤더에서 제공하는 가이드라인을 잘 지켜서 보안적인 위협이 없도록 해야한다.

## 13. 인가 / 인증

authn, authz는 클러스터에 접근을 제한하는 중요한 메커니즘이다. 클러스터가 잘못 설정되어있으면 인증/인가 없이 DB에 API로 접근하는 등의 우회가 가능하다. 

서비스 어카운트는 Pod의 API 호출을 담당한다. 앞서 언급했듯이, 일반적으로 서비스 어카운트 어드미션 컨트롤러가 서비스 어카운트의 베리어 토큰을 이용해서 인증을 관리한다.

어드미션 컨트롤러가 활성화상태면, 파드와 연결된 서비스 어카운트를 확인하고, 서비스 어카운트가 없으면 default 서비스 어카운터에 매핑시킨다. 

automountServiceAccountToken를 false로 설정하면 어드미션 컨트롤러가 파드를 default 서비스 어카운트에 자동으로 매핑시키지 않는다. 

서비스 어카운트마다 각각 별개의 권한을 할당할 수 있다. 서비스 어카운트가 생성되면 쿠버네티스는 자동으로 그 서비스 어카운트와 연결되는 시크릿을 생성하고, 서비스 어카운트와 연결된 파드가 그 시크릿을 사용할 수 있게 한다.

이 시크릿은 API에 접근할 수 있는 Credentials가 들어있다. 이 시크릿(토큰)이 만약 암호화나 보안적으로 보호되고 있지 않으면 외부 공격자가 이 시크릿을 통해 무단으로 API에 접근할 수 있게 된다. 그래서 파드 시크릿은 RBAC으로 접근 권한을 제어해야한다.

원래 default로는 토큰이 없어도 API 접근이 가능한데 RBAC 설정으로 이를 막아야하고, APIserver 설정 옵션으로 `--anonymous-auth=false를` 설정해서 annonymous request(토큰이 없는 요청)을 허용하지 않도록 설정해야한다.

## 14. Audit log

`audit log`를 통해 서비스가 잘 작동중인지, 의도한대로 설정이 되었는지, 리소스를 얼마나 사용하고있는지 등을 확인할 수 있다. 그러나 쿠버네티스에서 네이티브로 풀 모니터링과 audit을 지원하지는 않는다.

시스템관리자는 효과적인 모니터/로깅 시스템을 구축해야한다. 로깅은 host, application, container, container engine, image registry, api-server, and the cloud 등 클러스터의 모든 레벨에 걸쳐서 수집되어야한다. 이렇게 전 레벨에 걸쳐 수집된 로그는 하나의 시스템으로 모아서 확인할 수 있어야한다.

관리자가 새로운 파드를 생성하거나 파드를 업데이트하면, 반응속도, 요청, 네트워크 통신, 리소스 사용량 등의 메트릭을 확인할 수 있어야한다. RBAC 정책도 확인할 수 있어야한다. 

쿠버네티스 네이티브로는 API서버에 요청이 올 때마다 단계에 맞춰 로그를 남기도록 audit policy를 설정할 수 있다. default로는 audit 로그를 남기는게 disable로 설정되어있다. 관리자가 audit policy YAML을 직접 설정해야한다. audit policy는 None,  Metadata, Request, RequestResponse 중 하나의 레벨을 설정해야한다.

RequestResponse 레벨에서의 로깅은 가장 많은 정보를 주는 레벨인데, 대신 로그에 시크릿 정보가 포함될 수 있고, 필요하지 않은 로그 데이터까지 얻게 될 수 있다. 그래서 Metadata 레벨에서의 로깅을 추천한다.

워커노드에서도 kubelet을 통해 로그를 기록할 수 있다. 워커노드의 로그는 각 노드의 로컬에 저장되고, 커맨드를 통해 접근할 수 있다. 

이게 kubectl logs 로 확인하는 로그이다.

### Seccomp

컨테이너의 시스템 콜을 audit하기 위해서는 seccomp 도구를 사용할 수 있다. default로는 disable 상태이다. seccomp를 통해서 시스템 콜을 제한할 수 있고, 커널과 관련해 공격 당할한만 영역(attack surface)을 낮출 수 있다.

seccomp profile을 커스터마이징해서 어떤 시스템콜을 허가/거부할지, 어떤 시스템콜의 로그를 남길지를 결정할 수 있다. 관리자는 seccomp profile을 json형식으로 /var/lib/kubelet/seccomp/ 경로에 저장하고, 쿠버네티스 YAML 파일에서 securityContext 필드에 seccompProfile을 설정해서 적용시킬 수 있다.

### Syslog


쿠버네티스에서는 default로 kubelet의 로그를 남긴다. 이 로그는 kubectl logs POD_NAME으로 확인 가능하다. 만약 클러스터 전체의 모든 kubelet 로그를 모아서 syslog 서버에 저장하거나 따로 모아서 관리하고 싶다면 . Syslog message를 통해 수동으로 설정할 수 있다.

Syslog messages는 헤더와 본문이 있고, plain text(평문)으로 전달된다. Syslog daemons을 통해 모든 로그의 형식을 통일하고 한 곳에 모을 수 있다. 리눅스는 기본적으로 rsyslog나 journald라는 시스로그 데몬을 사용한다. 

### SIEM


SIEM은 Security Information and Event Management의 준말로, 네트워크 전반에 걸쳐 로그를 수집하는 소프트웨어 도구를 의미한다. 어플리케이션 뿐만 아니라 방화벽 등 전반적인 네트워크 로그를 수집한다. 점점 더 쿠버네티스와 완벽히 호환되면서 풀 모니터링을 제공하는 도구들이 개발되어지고 있다.

### ServiceMesh


서비스 메시의 사용이 필수인 것은 아니지만, 쿠버네티스와 너무 호환이 잘 된다. 로그를 남기기에도 좋고 서비스와 서비스 간 횡통신에도 mTLS를 이용한 암호화를 비교적 간단하게 구현할 수 있어 보안적으로 좋다.

### Fault tolerance


fault tolerance는 실패에도 서비스가 망가지지 않고 버티는 것을 의미한다. 로그 관련해서 fault tolerance policies를 설정하는 것이 중요하다. 로그 스토리지에 제한이 있을 떄, 기존 로그를 새 로그가 덮어쓸 수 있게 한다던지의 정책 설정이 fault tolerance의 한 예시이다.

### Threat Detection


로그관련해서 중요한 두가지는


1. 필요한 로그들을 빠짐없이 모두 수집하는 것
2. 긴급한 로그가 생겼을 때 실시간으로 모니터링할 수 있는 것

많은 로그 examination이 자동화되어있긴한데, 이걸 수동으로 manually 설정한다면 공격자가 접근할 때의 로그들이 잘 남을 수 있도록 설정하는 게 중요하다.

### Alert


쿠버네티스는 네이티브 alert 도구를 지원하지 않는다. 그래서 관리자가 적절한 alert 도구를 선정해서 긴급한 로그가 생성되었을 때 관리자와 클러스터에 알릴 수 있도록 쿠버네티스에 적용해야한다. 

## 15. References

[Kubernetes Hardening Guide](https://media.defense.gov/2022/Aug/29/2003066362/-1/-1/0/CTR_KUBERNETES_HARDENING_GUIDANCE_1.2_20220829.PDF)